# Java并发编程重点

## 基础概念

### 锁

**可重入**：“重入”意味着获取锁的操作的粒度是“线程”，而不是调用，一个线程可以多次获得锁。

**互斥锁**：指的是一次最多只能有一个线程持有的锁，比如synchronized和ReentrantLock，同时也是可重入。

### 线程中断

**interrupt**：用interrupt中断线程，并抛出InterruptedException异常。捕获异常让线程继续执行

**决断中断**：比如进入sleep之前就已经触发中断，这时候Main线程把Thread的中断标记设为true，继续执行，等到sleep一触发的时候马上触发中断。

**isInterrupted**：判断中断状态

### 守护线程

Java中有两类线程：User Thread\(用户线程\)、Daemon Thread\(守护线程\)。

**生命周期**

守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，比如垃圾回收线程就是一个守护线程。

当VM检测仅剩一个守护线程，而用户线程都已经退出运行时，VM就会退出。

**使用**

1. 用户可以用Thread的setDaemon（true）方法设置当前线程为守护线程。setDaemon\(true\)必须在调用线程的start（）方法之前设置，否则会跑出IllegalThreadStateException异常。
2. 在守护线程中产生的新线程也是守护线程。
3. 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作，用户线程一旦退出，VM就退出了

### **线程阻塞**

线程可以阻塞于四种状态：

1. Thread.sleep（）；
2. 当线程碰到一条wait（）语句时，它会一直阻塞到接到通知（notify\(\)）、被中断或经过了指定毫秒时间为止
3. I/O。常见的一种方式是InputStream的read\(\)方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间；
4. 线程也可以阻塞等待获取某个对象锁的排他性访问权限（即等待获得synchronized语句必须的锁时阻塞）。

注意，**并非所有的阻塞状态都是可中断的**，以上阻塞状态的前两种可以被中断，后两种不会对中断做出反应



## 参考

> [Java并发编程](http://www.importnew.com/20886.html)





