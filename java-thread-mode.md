# Java并发编程重点

## 基础概念

### 锁

**可重入**：“重入”意味着获取锁的操作的粒度是“线程”，而不是调用，一个线程可以多次获得锁。

**互斥锁**：指的是一次最多只能有一个线程持有的锁，比如synchronized和ReentrantLock，同时也是可重入。

### 线程中断

**interrupt**：用interrupt中断线程，并抛出InterruptedException异常。捕获异常让线程继续执行

**决断中断**：比如进入sleep之前就已经触发中断，这时候Main线程把Thread的中断标记设为true，继续执行，等到sleep一触发的时候马上触发中断。

**isInterrupted**：判断中断状态

### 守护线程

Java中有两类线程：User Thread\(用户线程\)、Daemon Thread\(守护线程\)。

**生命周期**

守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，比如垃圾回收线程就是一个守护线程。

当VM检测仅剩一个守护线程，而用户线程都已经退出运行时，VM就会退出。

**使用**

1. 用户可以用Thread的setDaemon（true）方法设置当前线程为守护线程。setDaemon\(true\)必须在调用线程的start\(\)方法之前设置，否则会跑出IllegalThreadStateException异常。
2. 在守护线程中产生的新线程也是守护线程。
3. 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作，用户线程一旦退出，VM就退出了

### **线程阻塞**

线程可以阻塞于四种状态：

1. `Thread.sleep()`；
2. 当线程碰到一条`wait()`语句时，它会一直阻塞到接到通知`notify()`、被中断或经过了指定毫秒时间为止
3. I/O。常见的一种方式是`InputStream`的`read()`方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间；
4. 线程也可以阻塞等待获取某个对象锁的排他性访问权限（即等待获得`synchronized`语句必须的锁时阻塞）。

注意，**并非所有的阻塞状态都是可中断的**，以上阻塞状态的前两种可以被中断，后两种不会对中断做出反应

### Runnable和Thread实现多线程的区别

Runnable接口相比继承Thread类有如下优势：

1. Runnable是接口，Thread是类，没有单继承局限
2. Runnable更好被复用
3. Runnable可以被多个线程共享，Thread只能是独立一个线程。[前者注意线程安全](http://www.importnew.com/20584.html)。

## volatile

Java 1.2之后的内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。

Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才将私有拷贝与共享内存中的原始值进行比较。

Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。

对于非volatile修饰的变量，尽管jvm的优化，会导致变量的可见性问题，但这种可见性的问题也只是在短时间内高并发的情况下发生，CPU执行时会很快刷新Cache，一般的情况下很难出现，而且出现这种问题是不可预测的，与jvm, 机器配置环境等都有关。

## synchronized

**概念**

* 多线程同时并发访问的资源叫做临界资源
* 采用synchronized修饰符所获得的锁,叫做互斥锁。每个对象的锁只能分配给一个线程，因此叫做互斥锁。
* 每个对象都有一个monitor\(锁标记\)。synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。
* 当线程拥有锁标记时才能访问这个资源，没有锁标记便进入锁池。
* 任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。

**同步机制获取互斥锁**

* 如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝。
* 类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的synchronized同步代码块或方法时，便获取了该实例的对象级别锁。其他线程访问该实例中被synchronized修饰的代码块时，被阻塞。但是不同实例对象相互不影响。
* 类级别锁被特定类的所有示例共享，它用于控制对static成员变量以及static方法的并发访问。
* 
## wait/notify

Object是所有类的超类，它有5个方法组成了等待/通知机制的核心：notify\(\)、notifyAll\(\)、wait\(\)、wait\(long\)和wait\(long，int\)，都被声明为final。

### wait和notify

* 在调用之前，线程必须要获得对象级别锁，即只能在同步方法或同步块中调用。
* 如果调用时，没有持有适当的锁，则抛出IllegalMonitorStateException。

**wait** 该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。进入wait\(\)方法后，当前线程释放锁。在从wait\(\)返回前，线程与其他线程竞争重新获得锁。

**notify** notify后，当前线程不会马上释放该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁

### 深入理解

* 如果线程调用了对象的wait\(\)方法，那么线程便会处于该对象的等待池中，**等待池**中的线程不会去竞争该对象的锁。
* 被唤醒\(notify\)的的线程便会进入该对象的**锁池**中，锁池中的线程会去竞争该对象锁。

**通知遗漏** threadA还没开始wait的时候，threadB已经notify了，这样，threadB通知是没有任何响应的，当threadB退出synchronized代码块后，threadA再开始wait，便会一直阻塞等待，直到被别的线程打断（interrupt）。 [通知遗漏一般可以用boolean变量值规避](http://www.importnew.com/20677.html)。

### sleep\(\)和wait\(\)的区别

sleep只释放cpu资源，不改变锁状态；wait释放了锁，notify后继续执行后面的代码。

* sleep\(\)是Thread的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。 

  因为sleep\(\)是static的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep\(\)方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。

* wait\(\)是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问

### 线程的四种状态

* 新建（new）：处于该状态的时间很短暂。已被分配了必须的系统资源，并执行了初始化。表示有资格获得CPU时间。调度器可以把该线程变为runnable或者blocked状态
* 就绪（Runnable）：这种状态下只要调度器把时间片分配给线程，线程就能运行。处在这种状态就是可运行可不运行的状态
* 阻塞（Bolocked）：线程能够运行，但有个条件阻止它的运行。当线程处于阻塞状态时，调度器将会忽略线程，不会分配给线程任何CPU时间（例如sleep）。只有重新进入了就绪状态，才有可能执行操作。
* 死亡（Dead）：处于死亡状态的线程讲不再是可调度的，并且再也不会得到CPU时间。任务死亡的通常方式是从run\(\)方法返回。

![https://blog.csdn.net/a58220655/article/details/76695142](.gitbook/assets/image%20%282%29.png)

## Java安全使用集合

[Collections类可以获取通过同步方法封装非同步集合而得到的集合](http://www.importnew.com/20624.html)。

## 线程模式

### 生产者-消费者模型

[http://www.importnew.com/20709.html](http://www.importnew.com/20709.html)

## 参考

> [Java并发编程](http://www.importnew.com/20886.html)

