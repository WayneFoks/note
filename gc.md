# GC机制



### 推荐文章

[Java虚拟机垃圾回收\(三\) 7种垃圾收集器](https://blog.csdn.net/tjiyu/article/details/53983650) [Debugging ART Garbage Collection](https://source.android.google.cn/devices/tech/dalvik/gc-debug)

### Java回收分类

新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge 老年代收集器使用的收集器：Serial Old、Parallel Old、CMS 

![](.gitbook/assets/image%20%2813%29.png)

**Serial收集器（复制算法\)**

新生代单线程收集器，标记和清理都是单线程，优点是简单高效。

**Serial Old收集器\(标记-整理算法\)**

老年代单线程收集器，Serial收集器的老年代版本。

**ParNew收集器\(停止-复制算法\)**

新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。

**Parallel Scavenge收集器\(停止-复制算法\)**

并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/\(用户线程时间+GC线程时间\)。适合后台应用等对交互相应要求不高的场景。

**Parallel Old收集器\(停止-复制算法\)**

Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先

**CMS\(Concurrent Mark Sweep\)收集器（标记-清理算法）**

高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择

#### 串行收集器

![](.gitbook/assets/image%20%285%29.png)

> 开启选项：-XX:+SerialGC

采用单线程stop-the-world（STW）的方式进行收集。当内存不足时，串行GC设置停顿标识，待所有线程都进入安全点\(Safepoint\)时，应用线程暂停，串行GC开始工作，采用单线程方式回收空间并整理内存。

#### 并行收集器

![](.gitbook/assets/image%20%2823%29.png)

是stop-the-world（STW）方式，只是暂停时并行地进行垃圾收集。年轻代采用复制算法，老年代采用标记-整理。

#### 并发标记清除收集器（CMS）

[https://www.jianshu.com/p/2a1b2f17d3e4](https://www.jianshu.com/p/2a1b2f17d3e4)

![](.gitbook/assets/image%20%2819%29.png)

并发标记清除\(CMS\)是以关注延迟为目标、十分优秀的垃圾回收算法，开启后，年轻代使用stop-the-world（STW）式的并行收集，老年代回收采用CMS进行垃圾回收，对延迟的关注也主要体现在老年代CMS上。

CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。

但是CMS并不完美，它有以下缺点：

由于并发进行，CMS在收集与应用线程会同时会增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间；

标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。

#### Garbage First（G1）

![](.gitbook/assets/image%20%283%29.png)

之前介绍的几组垃圾收集器组合，都有几个共同点：

* 年轻代、老年代是独立且连续的内存块；
* 年轻代收集使用单eden、双survivor进行复制算法；
* 老年代收集必须扫描整个老年代区域；
* 都是以尽可能少而快地执行GC为设计原则。

G1收集与以上三组收集器有很大不同：

G1的设计原则是”首先收集尽可能多的垃圾\(Garbage First\)“。

G1并不会等内存耗尽\(串行、并行\)或者快耗尽\(CMS\)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；

G1采用内存分区\(Region\)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案\(局部压缩\)；

G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor\(to space\)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；

G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合\(mixed\)收集的方式。即每次收集既可能只收集年轻代分区\(年轻代收集\)，也可能在收集年轻代的同时，包含部分老年代分区\(混合收集\)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。

### 垃圾回收算法

（[http://www.cnblogs.com/killmyday/archive/2013/06/12/3132518.html）](http://www.cnblogs.com/killmyday/archive/2013/06/12/3132518.html）)

#### 引用计数回收法（Reference Counting GC）

**算法描述**

* 堆中每个对象实例都有一个引用计数。对象创建并分配到一个变量，计数设置为1。
* 当任何其它变量被赋值为这个对象的引用时，计数加1。
* 当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。
* 任何引用计数器为0的对象实例可以被当作垃圾收集。
* 当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。

**算法分析**

优点：引用计数收集器可以很快的执行，交织在程序运行中。 缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.

#### Tracing算法\(`Tracing Collector`\)

是从离散数学中的图论引入的把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点。

java中可作为GC Root的对象有： 1. 虚拟机栈中引用的对象（本地变量表） 2. 方法区中静态属性引用的对象 3. 方法区中常量引用的对象 4. 本地方法栈中引用的对象（Native对象）

#### 标注并清理回收法`(Mark and Sweep GC`\)

标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。

#### 标注并整理回收法（Mark and COMPACT GC）

标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。

#### Copying算法\(Compacting Collector\)

该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成一个对象面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，将每个 活动对象复制到空闲面\(使得活动对象所占的内存之间没有空闲洞\)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。

#### Generation算法\(Generational Collector\)

![](.gitbook/assets/image%20%2817%29.png)

### Android的GC

[Debugging ART Garbage Collection](https://source.android.google.cn/devices/tech/dalvik/gc-debug)

### 内存错误

* 栈溢出\(StackOverflowError\)
* 堆溢出\(OutOfMemoryError:Java heap space\)
* 永久代溢出\(OutOfMemoryError: PermGen space\)
* Native内存溢出

> [https://blog.csdn.net/u011983531/article/details/63250882](https://blog.csdn.net/u011983531/article/details/63250882)

### 参考

> [详解 JVM Garbage First\(G1\) 垃圾收集器](https://blog.csdn.net/coderlius/article/details/79272773)

